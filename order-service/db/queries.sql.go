// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"

	"time"
)

const addOrderItem = `-- name: AddOrderItem :exec
INSERT INTO order_items (
    order_item_id, order_id, dish_id, dish_order_status, quantity, price_per_unit, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP
)
`

type AddOrderItemParams struct {
	OrderItemID     string  `json:"orderItemId"`
	OrderID         string  `json:"orderId"`
	DishID          string  `json:"dishId"`
	DishOrderStatus string  `json:"dishOrderStatus"`
	Quantity        int32   `json:"quantity"`
	PricePerUnit    float64 `json:"pricePerUnit"`
}

func (q *Queries) AddOrderItem(ctx context.Context, arg AddOrderItemParams) error {
	_, err := q.db.Exec(ctx, addOrderItem,
		arg.OrderItemID,
		arg.OrderID,
		arg.DishID,
		arg.DishOrderStatus,
		arg.Quantity,
		arg.PricePerUnit,
	)
	return err
}

const countActiveOrderItems = `-- name: CountActiveOrderItems :one
SELECT COUNT(*) 
FROM order_items 
WHERE order_id = $1 
AND deleted_at IS NULL
`

func (q *Queries) CountActiveOrderItems(ctx context.Context, orderID string) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveOrderItems, orderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :exec
INSERT INTO orders (
    order_id, user_id, chef_id, total_price, pickup_time, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
`

type CreateOrderParams struct {
	OrderID    string      `json:"orderId"`
	UserID     string      `json:"userId"`
	ChefID     string      `json:"chefId"`
	TotalPrice float64     `json:"totalPrice"`
	PickupTime **time.Time `json:"pickupTime"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.Exec(ctx, createOrder,
		arg.OrderID,
		arg.UserID,
		arg.ChefID,
		arg.TotalPrice,
		arg.PickupTime,
	)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
UPDATE orders 
SET deleted_at = CURRENT_TIMESTAMP 
WHERE order_id = $1 
AND deleted_at IS NULL
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID string) error {
	_, err := q.db.Exec(ctx, deleteOrder, orderID)
	return err
}

const deleteOrderItem = `-- name: DeleteOrderItem :one
UPDATE order_items 
SET deleted_at = CURRENT_TIMESTAMP 
WHERE order_item_id = $1 
AND deleted_at IS NULL
RETURNING order_item_id
`

func (q *Queries) DeleteOrderItem(ctx context.Context, orderItemID string) (string, error) {
	row := q.db.QueryRow(ctx, deleteOrderItem, orderItemID)
	var order_item_id string
	err := row.Scan(&order_item_id)
	return order_item_id, err
}

const getChefOrders = `-- name: GetChefOrders :many
SELECT order_id, user_id, chef_id, total_price, pickup_time, created_at, updated_at, canceled_at, completed_at, order_status, deleted_at 
FROM orders
WHERE chef_id = $1 
  AND deleted_at IS NULL
`

func (q *Queries) GetChefOrders(ctx context.Context, chefID string) ([]Order, error) {
	rows, err := q.db.Query(ctx, getChefOrders, chefID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.ChefID,
			&i.TotalPrice,
			&i.PickupTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CanceledAt,
			&i.CompletedAt,
			&i.OrderStatus,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderIDByOrderItem = `-- name: GetOrderIDByOrderItem :one
SELECT order_id 
FROM order_items 
WHERE order_item_id = $1
`

func (q *Queries) GetOrderIDByOrderItem(ctx context.Context, orderItemID string) (string, error) {
	row := q.db.QueryRow(ctx, getOrderIDByOrderItem, orderItemID)
	var order_id string
	err := row.Scan(&order_id)
	return order_id, err
}

const getOrderItemStatus = `-- name: GetOrderItemStatus :one
SELECT dish_order_status 
FROM order_items 
WHERE order_item_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetOrderItemStatus(ctx context.Context, orderItemID string) (string, error) {
	row := q.db.QueryRow(ctx, getOrderItemStatus, orderItemID)
	var dish_order_status string
	err := row.Scan(&dish_order_status)
	return dish_order_status, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT order_item_id, order_id, dish_id, dish_order_status, quantity, price_per_unit, created_at, deleted_at
FROM order_items
WHERE order_id = $1
`

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID string) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.DishID,
			&i.DishOrderStatus,
			&i.Quantity,
			&i.PricePerUnit,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrders = `-- name: GetUserOrders :many
SELECT order_id, user_id, chef_id, total_price, pickup_time, created_at, updated_at, canceled_at, completed_at, order_status, deleted_at 
FROM orders
WHERE user_id = $1 
  AND deleted_at IS NULL
`

func (q *Queries) GetUserOrders(ctx context.Context, userID string) ([]Order, error) {
	rows, err := q.db.Query(ctx, getUserOrders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.ChefID,
			&i.TotalPrice,
			&i.PickupTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CanceledAt,
			&i.CompletedAt,
			&i.OrderStatus,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteItem = `-- name: HardDeleteItem :exec
DELETE FROM order_items
WHERE order_item_id = $1
`

func (q *Queries) HardDeleteItem(ctx context.Context, orderItemID string) error {
	_, err := q.db.Exec(ctx, hardDeleteItem, orderItemID)
	return err
}

const hardDeleteOrder = `-- name: HardDeleteOrder :exec
DELETE FROM orders
WHERE order_id = $1
`

func (q *Queries) HardDeleteOrder(ctx context.Context, orderID string) error {
	_, err := q.db.Exec(ctx, hardDeleteOrder, orderID)
	return err
}

const softDeleteItem = `-- name: SoftDeleteItem :exec
UPDATE order_items
SET deleted_at = CURRENT_TIMESTAMP
WHERE order_item_id = $1
`

func (q *Queries) SoftDeleteItem(ctx context.Context, orderItemID string) error {
	_, err := q.db.Exec(ctx, softDeleteItem, orderItemID)
	return err
}

const softDeleteOrder = `-- name: SoftDeleteOrder :exec
UPDATE orders
SET deleted_at = CURRENT_TIMESTAMP
WHERE order_id = $1
`

func (q *Queries) SoftDeleteOrder(ctx context.Context, orderID string) error {
	_, err := q.db.Exec(ctx, softDeleteOrder, orderID)
	return err
}

const updateOrderItemStatus = `-- name: UpdateOrderItemStatus :exec
UPDATE order_items
SET dish_order_status = $2
WHERE order_item_id = $1 AND deleted_at IS NULL
`

type UpdateOrderItemStatusParams struct {
	OrderItemID     string `json:"orderItemId"`
	DishOrderStatus string `json:"dishOrderStatus"`
}

func (q *Queries) UpdateOrderItemStatus(ctx context.Context, arg UpdateOrderItemStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderItemStatus, arg.OrderItemID, arg.DishOrderStatus)
	return err
}
